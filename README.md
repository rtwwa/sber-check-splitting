# Внутренняя логика проекта
Используемые библиотеки во всех микросервисах:
- `requests` (HTTP-запросы между сервисами)
- `random` (генерация случайных значений, например, хэшей)
- `pydantic` (валидация и сериализация данных)
- `fastapi` (создание REST API)
- `pytesseract` (OCR-распознавание текста с изображений)
- `PIL` (обработка изображений, загрузка и преобразование)
- `redis` (работа с in-memory хранилищем Redis)

## Разберём backend поэтапно
### Реализация микросервиса *memCache*
В данном блоке осуществляется взаимодействие с NoSQL базой данных Redis, которая используется для временного хранения и обмена данными между микросервисами. Это позволяет эффективно реализовать быструю и надёжную межсервисную коммуникацию. В рамках блока реализованы методы для сохранения, получения и удаления данных по ключу, что обеспечивает гибкость и высокую производительность при работе с распределёнными системами. Redis выступает в роли кэш-хранилища и промежуточного слоя передачи данных.

### Реализация микросервиса *OCR (оптическое распознавание символов)*
В данном блоке реализована загрузка изображения чека пользователем на определённый endpoint, обозначенный в коде как `load-image`. После получения изображения осуществляется его обработка с использованием OCR-технологии, извлечение текста и последующее преобразование данных в структурированный формат JSON. Результирующий JSON представляет собой модель, включающую итоговую сумму чека и перечень позиций, каждая из которых содержит название товара, количество порций, цену за единицу и общую стоимость.

**Пример структуры:**
```
{
  "total_account": <общая сумма>,
  "products": [
    {
      "name": "Название товара",
      "numberServings": <кол-во>,
      "price": <цена за единицу>,
      "total": <сумма>
    }
  ]
}
```
После формирования JSON-объекта в этом же микросервисе генерируется уникальная ссылка, например:
`http://localhost:8090/small-router/lBF2niuPbm`

В данной ссылке:

`8090` — порт другого микросервиса, выполняющего функции маршрутизатора;

`small-router` — путь, по которому происходит обращение к API маршрутизатора;

`lBF2niuPbm` — уникальный ключ, предназначенный для идентификации конкретного чека и последующей работы с ним.

Уникальный ключ также сохраняется в Redis в формате `cheque:lBF2niuPbm`, что обеспечивает удобный и быстрый доступ к информации. Такой подход позволяет организовать совместную работу с чеком: пользователю, загрузившему изображение, возвращается URL-ссылка, которую он может отправить другим участникам, например, в общий чат. Перейдя по этой ссылке, другие пользователи смогут ознакомиться с содержимым чека, принять участие в его разборе и выбрать подходящий метод деления суммы.

Таким образом, блок отвечает за приём данных, их обработку, формирование модели, сохранение во временное хранилище Redis и генерацию уникальной ссылки для дальнейшего взаимодействия между пользователями и микросервисами.

### Реализация микросервиса *SmartRouter*
В результате перехода по ссылке, сгенерированной в предыдущем микросервисе, клиент получает в ответе словарь, содержащий уникальный хэш и связанные с ним данные, извлечённые из Redis. Такой механизм позволяет обеспечить быстрый и удобный доступ к ранее сохранённой информации, связанной с конкретным чеком. Пользователи, получившие ссылку, могут перейти по ней и автоматически получить расшифрованное содержимое чека, загруженного первым участником. Это создаёт удобный сценарий коллективной работы с данными, например, для совместного анализа, деления суммы заказа или принятия решений на основе общего счёта. Подход с использованием уникального хэша и Redis обеспечивает высокую производительность и масштабируемость.

**Основные трудности** возникали на этапе проектирования логики взаимодействия между микросервисами. Необходимо было продумать надёжный и в то же время простой механизм обмена данными, обеспечивающий согласованность и скорость отклика между компонентами системы. Особую сложность представлял выбор подходящей базы данных, которая бы обеспечивала быстрый доступ к временным данным и эффективно справлялась с задачами кэширования и хранения по ключу. В результате было принято решение использовать Redis — лёгкое и производительное NoSQL-хранилище, идеально подходящее для реализации быстрого поиска и временного хранения данных, необходимых для работы микросервисов в реальном времени.

**Общий поток данных:**
1. Пользователь загружает фотографию, которая сохраняется на backend-сервере.
2. Backend возвращает уникальную ссылку на изображение.
3. Другие пользователи переходят по этой ссылке.
4. При переходе отображаются данные, связанные с изображением.
5. Каждый из пользователей переводит денежные средства на счёт первого пользователя.

Если вам стало интересно, вы можете ознакомиться с кодом внутри микросервисов — соответствующие участки помечены и закомментированы для удобства.
